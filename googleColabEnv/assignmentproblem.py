# -*- coding: utf-8 -*-
"""assignmentProblem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1imcijos-3VHyvYw7vyhCD3d3rrWZT2E8
"""

# ライブラリのインストール
!pip install pulp

"""自転車の現在地とホームポジションデータをランダムに生成"""

import pandas as pd
import numpy as np

# シード値を設定
np.random.seed(4)

# 自転車の位置情報をランダムに生成
num_positions = 5  # 5個の位置情報を生成
min_coord, max_coord = 0, 100  # 座標の範囲（0から100）
home_positions = [(np.random.randint(min_coord, max_coord), np.random.randint(min_coord, max_coord)) for _ in range(num_positions)]

# 現在地情報（座標）をランダムに生成
current_locations = [(np.random.randint(min_coord, max_coord), np.random.randint(min_coord, max_coord)) for _ in range(num_positions)]

# データフレームを作成
bike_data = {
    'Home Position': home_positions,
    'Current Location': current_locations
}

df_bikes = pd.DataFrame(bike_data)

# Current Location == Home Positionの場合のデータを追加
num_same_positions = 5
same_locations =[(np.random.randint(min_coord, max_coord), np.random.randint(min_coord, max_coord)) for _ in range(num_same_positions)]
new_row = pd.DataFrame({'Home Position': same_locations, 'Current Location': same_locations})
df_bikes = pd.concat([df_bikes, new_row], ignore_index=True)

# 'Bike ID' 列を最初のカラムとして追加
df_bikes.insert(0, 'Bike ID', df_bikes.index)
# Bike ID をインデックスとして設定
df_bikes.set_index('Bike ID', inplace=True)

df_bikes

"""ユーザー情報を別のデータフレームとして保持"""

user_data = {
    'User': ['User 1', 'User 2'],
    'Current Position': [(58, 45), (70, 50)],
    'Destination': [(80, 80), (70, 70)]
}

df_users = pd.DataFrame(user_data)

# 'Assigned Bike ID' 列を追加し、初期値を -1 に設定
df_users['Assigned Bike ID'] = -1

# 'User ID' 列を最初のカラムとして追加
df_users.insert(0, 'User ID', df_users.index)
# User ID をインデックスとして設定
df_users.set_index('User ID', inplace=True)

df_users

"""以下の二種類の情報をプロットする
- 自転車の現在地とホームポジションまでの方向
- ユーザーの現在地と目的地までの方向
"""

import matplotlib.pyplot as plt

# プロットを作成
plt.figure(figsize=(8, 8))

# 自転車と自宅位置のプロット
for index, row in df_bikes.iterrows():
    # 現在地をプロット
    plt.scatter(row['Current Location'][0], row['Current Location'][1],
                marker='o', color='blue', zorder=2,
                label="Current Location (Bike)" if index == 0 else "")
    # 自宅位置をプロット
    plt.scatter(row['Home Position'][0], row['Home Position'][1],
                marker='s', color='green', s=100, zorder=1,
                label="Home Position (Bike)" if index == 0 else "")
    # 矢印をプロット
    # 見やすさの観点から矢印の長さを短くしてプロット
    plt.arrow(row['Current Location'][0], row['Current Location'][1],
              row['Home Position'][0] - row['Current Location'][0],
              row['Home Position'][1] - row['Current Location'][1],
              head_width=3, head_length=3, fc='black', ec='black',
              length_includes_head=True, zorder=3,
              label="Direction to Home (Bike)" if index == 0 else "")

# ユーザーの位置と目的地のプロット
for index, row in df_users.iterrows():
    # 現在地をプロット
    plt.scatter(row['Current Position'][0], row['Current Position'][1],
                marker='*', color='red', s=200, zorder=1,
                label="Current Location (User)" if index == 0 else "")
    # 矢印をプロット
    plt.arrow(row['Current Position'][0], row['Current Position'][1],
              row['Destination'][0] - row['Current Position'][0],
              row['Destination'][1] - row['Current Position'][1],
              head_width=3, head_length=3, fc='red', ec='red',
              length_includes_head=True, zorder=3,
              label="User Destination" if index == 0 else "")

# y軸をLatitudeに設定
plt.xlabel('Latitude')
# x軸をLongitudeに設定
plt.ylabel('Longitude')
plt.title('Bike Positions and Home Locations')
plt.grid(True)
plt.legend()
plt.show()

"""自転車の分散を定量的に評価する<br>
分散の具体的な評価方法としては，各々の自転車の現在地とホームポジションのユーグリッド距離を計算し，それらの総和を分散とする．<br>

$\sum_{b \in B} \underbrace{\| \mathbf{v}_b \|}_{\text{現在地からホームポジションへの方向ベクトルのノルムの総和}}$

【TODO】今後の課題としては，ユーグリッド距離よりもマンハッタン距離を用いたほうが本質的な自転車の分散を取得することができるため検討する．
"""

def calculate_total_distance(df):
    """
    データフレームからホームポジションとカレントポジションのノルムの総和を計算する関数。

    :param df: ホームポジションとカレントポジションを含むデータフレーム
    :return: 距離の総和
    """
    total_distance = 0
    for _, row in df.iterrows():
        home_pos = np.array(row['Home Position'])
        current_loc = np.array(row['Current Location'])
        distance = np.linalg.norm(home_pos - current_loc)
        total_distance += distance
    return total_distance

# ホームポジションと現在地の距離の分散を計算
print("初期状態におけるノルムの総和：", calculate_total_distance(df_bikes))

"""実際のユーザーの位置座標と目的地から数値実験を試みる"""

def update_bike_location(df_bikes, bike_index, new_destination):
    """
    自転車の現在位置を更新する関数。新しい位置はnumpy配列で指定。

    :param df_bikes: 自転車情報を含むデータフレーム
    :param bike_index: 更新する自転車のインデックス
    :param new_destination: 新しい目的地（numpy配列形式の座標、例：np.array([x, y])）
    """

    # バリデーション
    # 実際に更新を試みる前に、インデックスとデータ型を確認
    if isinstance(new_destination, (list, np.ndarray)) and len(new_destination) == 2:
        try:
            # インデックスが有効か確認
            if bike_index in df_bikes.index:
                # 指定された自転車の現在位置を新しい目的地に更新
                # df_bikes.loc[bike_index, 'Current Location'] = tuple(new_destination)
                df_bikes.at[bike_index, 'Current Location'] = tuple(new_destination)
                # print("Update successful!")
                return df_bikes
            else:
                print("Error: bike_index is out of bounds.")
        except Exception as e:
            print("An error occurred:", e)
    else:
        print("Error: new_destination is not in the correct format or size.")


def update_user(df_users, user_index, assigned_bike_id, new_destination):
    """
    ユーザーの現在位置を更新する関数。新しい位置はnumpy配列で指定。

    :param df_users: ユーザー情報を含むデータフレーム
    :param user_index: 更新するユーザーのインデックス
    :param assigned_bike_id: ユーザーに割り当てられる自転車のID
    :param new_destination: 新しい目的地（numpy配列形式の座標、例：np.array([x, y])）
    """
    # ユーザーインデックスのバリデーション
    if user_index not in df_users.index:
        raise ValueError("指定されたuser_indexはデータフレームの範囲外です。")

    # new_destinationのバリデーション
    if not isinstance(new_destination, np.ndarray) or new_destination.shape != (2,):
        raise ValueError("new_destinationは2要素のnumpy配列である必要があります。")

    # assigned_bike_idのバリデーション
    if not isinstance(assigned_bike_id, int):
        raise ValueError("assigned_bike_idは整数である必要があります。")


    # 指定されたユーザーの現在位置を新しい目的地に更新
    df_users.at[user_index, 'Current Position'] = tuple(new_destination)
    # ユーザーに割り当てられた自転車IDを更新
    df_users.at[user_index, 'Assigned Bike ID'] = assigned_bike_id
    # 【WANT TO DO】この情報を履歴DBに格納する方にしたい。

    return df_users

import pulp

# ユーザーごとに最適化を行う
for user_index, user_row in df_users.iterrows():
    user_position = np.array(user_row['Current Position'])
    destination = np.array(user_row['Destination'])

    # 制約(1): 半径rの距離内の自転車を特定
    radius = 16

    # 制約(2): radius内に利用可能な自転車が1つ以下の場合は半径を広げて探索(最大2回の拡張とする)
    loopIndex = 0
    MAX_SEARCH = 2
    available_bikes = []
    while len(available_bikes) < 2:
        for index, row in df_bikes.iterrows():
            distance = np.linalg.norm(np.array(row['Current Location']) - user_position)
            if distance <= radius:
                available_bikes.append(index)

        loopIndex += 1
        if loopIndex > MAX_SEARCH or len(available_bikes) >= 2:
            break;

        # 利用可能な自転車が無い場合、探索範囲を拡張
        radius += 2

    # モデルの定義
    # スペースをアンダースコアに変換
    user_name = user_row['User'].replace(' ', '_')
    model = pulp.LpProblem("Bike_Allocation_for_{}".format(user_name), pulp.LpMinimize)

    # 変数の定義
    bike_vars = pulp.LpVariable.dicts("Bike", available_bikes, cat="Binary")

    # 目的関数の定義: 移動後の自転車の目的地とホームポジションの距離(分散)を最小化
    model += pulp.lpSum([np.linalg.norm(np.array(df_bikes.loc[bike, 'Home Position']) - destination) * bike_vars[bike] for bike in available_bikes])

    # 制約条件の定義: 選択された自転車は1つと仮定
    model += pulp.lpSum([bike_vars[bike] for bike in available_bikes]) == 1

    # 最適化の実行
    model.solve()

    # 結果の表示
    print("Optimization result for", user_row['User'])
    is_successed_optimization = False
    for bike in available_bikes:
        if pulp.value(bike_vars[bike]) == 1:
            # 更新処理
            df_bikes = update_bike_location(df_bikes, bike, destination)
            df_users = update_user_location(df_users, user_index, destination)
            is_successed_optimization = True

            print("Assigned bike:", bike, "at location", df_bikes.loc[bike, 'Current Location'])
            print()
            break

    if not is_successed_optimization:
      print("適切な自転車が見つかりませんでした。")

df_bikes
# df_users

import matplotlib.pyplot as plt

# プロットを作成
plt.figure(figsize=(8, 8))

# 自転車と自宅位置のプロット
for index, row in df_bikes.iterrows():
    # 現在地をプロット
    plt.scatter(row['Current Location'][0], row['Current Location'][1],
                marker='o', color='blue', zorder=2,
                label="Current Location (Bike)" if index == 0 else "")
    # 自宅位置をプロット
    plt.scatter(row['Home Position'][0], row['Home Position'][1],
                marker='s', color='green', s=100, zorder=1,
                label="Home Position (Bike)" if index == 0 else "")
    # 矢印をプロット
    # 見やすさの観点から矢印の長さを短くしてプロット
    plt.arrow(row['Current Location'][0], row['Current Location'][1],
              row['Home Position'][0] - row['Current Location'][0],
              row['Home Position'][1] - row['Current Location'][1],
              head_width=3, head_length=3, fc='black', ec='black',
              length_includes_head=True, zorder=3,
              label="Direction to Home (Bike)" if index == 0 else "")

# ユーザーの位置と目的地のプロット
for index, row in df_users.iterrows():
    # 現在地をプロット
    plt.scatter(row['Current Position'][0], row['Current Position'][1],
                marker='*', color='red', s=200, zorder=1,
                label="Current Location (User)" if index == 0 else "")

# y軸をLatitudeに設定
plt.xlabel('Latitude')
# x軸をLongitudeに設定
plt.ylabel('Longitude')
plt.title('Bike Positions and Home Locations')
plt.grid(True)
plt.legend()
plt.show()

"""キューとして保持していたユーザーのデータフレームにおいて、マッチングが成立したデータを削除する。"""

# 'Assigned Bike ID'が-1ではない行を削除
df_users = df_users[df_users['Assigned Bike ID'] == -1]

# 結果の表示
df_users

print("移動後の自転車のノルムの総和:", calculate_total_distance(df_bikes))

"""ランダムに生成した100ユーザーでシミュレートしてみる"""

# 100人分のランダムな現在位置と目的地を生成
current_positions = [(np.random.randint(0, 100), np.random.randint(0, 100)) for _ in range(100)]
destinations = [(np.random.randint(0, 100), np.random.randint(0, 100)) for _ in range(100)]

# ユーザーデータの辞書を作成
user_data = {
    'User': [f'User {i + 1}' for i in range(100)],
    'Current Position': current_positions,
    'Destination': destinations,
    'Assigned Bike ID': [-1] * 100  # すべてのユーザーに対して初期値 -1 を設定
}

# データフレームの作成
df_users = pd.DataFrame(user_data)

# 'User ID' 列を最初のカラムとして追加し、インデックスとして設定
df_users.insert(0, 'User ID', df_users.index)
df_users.set_index('User ID', inplace=True)

# 結果の表示
df_users

"""ユーザー100人に対して最適化を実行する

【TO DO】この処理は複数箇所で出現しているため、共通化したい。
"""

import pulp

# ユーザーごとに最適化を行う
for user_index, user_row in df_users.iterrows():
    user_position = np.array(user_row['Current Position'])
    destination = np.array(user_row['Destination'])

    # 制約(1): 半径rの距離内の自転車を特定
    radius = 16

    # 制約(2): radius内に利用可能な自転車が1つ以下の場合は半径を広げて探索(最大2回の拡張とする)
    loopIndex = 0
    MAX_SEARCH = 2
    available_bikes = []
    while len(available_bikes) < 2:
        for index, row in df_bikes.iterrows():
            distance = np.linalg.norm(np.array(row['Current Location']) - user_position)
            if distance <= radius:
                available_bikes.append(index)

        loopIndex += 1
        if loopIndex > MAX_SEARCH or len(available_bikes) >= 2:
            break;

        # 利用可能な自転車が無い場合、探索範囲を拡張
        radius += 2

    # モデルの定義
    # スペースをアンダースコアに変換
    user_name = user_row['User'].replace(' ', '_')
    model = pulp.LpProblem("Bike_Allocation_for_{}".format(user_name), pulp.LpMinimize)

    # 変数の定義
    bike_vars = pulp.LpVariable.dicts("Bike", available_bikes, cat="Binary")

    # 目的関数の定義: 移動後の自転車の目的地とホームポジションの距離(分散)を最小化
    model += pulp.lpSum([np.linalg.norm(np.array(df_bikes.loc[bike, 'Home Position']) - destination) * bike_vars[bike] for bike in available_bikes])

    # 制約条件の定義: 選択された自転車は1つと仮定
    # 【TO DO】実際は「1つ以下」という条件であるべきだが，そうするとマッチングしなくなってしまう。
    model += pulp.lpSum([bike_vars[bike] for bike in available_bikes]) == 1

    # 最適化の実行
    model.solve()

    # 結果の表示
    print("Optimization result for", user_row['User'])
    is_successed_optimization = False
    for bike in available_bikes:
        if pulp.value(bike_vars[bike]) == 1:
            # 更新処理
            df_bikes = update_bike_location(df_bikes, bike, destination)
            df_users = update_user(df_users, user_index, bike, destination)
            is_successed_optimization = True

            print("Assigned bike:", bike, "at location", df_bikes.loc[bike, 'Current Location'])
            print()
            break

    if not is_successed_optimization:
      print("適切な自転車が見つかりませんでした。")

# 結果の表示
df_users

"""キューとして保持していたユーザーのデータフレームにおいて、マッチングが成立したデータを削除する。

【TO DO】キュー配列の更新関数を作成する必要がある。
"""

# 'Assigned Bike ID'が-1ではない行を削除
df_users = df_users[df_users['Assigned Bike ID'] == -1]

# 結果の表示
df_users

"""ユーザー数100人でシミュレートした結果をプロット

【TO DO】プロットする部分を共通化する必要がある。何をプロットするのか否かを引数として受け取って図を出力したい。
"""

import matplotlib.pyplot as plt

# プロットを作成
plt.figure(figsize=(8, 8))

# 自転車と自宅位置のプロット
for index, row in df_bikes.iterrows():
    # 現在地をプロット
    plt.scatter(row['Current Location'][0], row['Current Location'][1],
                marker='o', color='blue', zorder=2,
                label="Current Location (Bike)" if index == 0 else "")
    # 自宅位置をプロット
    plt.scatter(row['Home Position'][0], row['Home Position'][1],
                marker='s', color='green', s=100, zorder=1,
                label="Home Position (Bike)" if index == 0 else "")
    # 矢印をプロット
    # 見やすさの観点から矢印の長さを短くしてプロット
    plt.arrow(row['Current Location'][0], row['Current Location'][1],
              row['Home Position'][0] - row['Current Location'][0],
              row['Home Position'][1] - row['Current Location'][1],
              head_width=3, head_length=3, fc='black', ec='black',
              length_includes_head=True, zorder=3,
              label="Direction to Home (Bike)" if index == 0 else "")

# ユーザーの位置と目的地のプロット
# for index, row in df_users.iterrows():
#     # 現在地をプロット
#     plt.scatter(row['Current Position'][0], row['Current Position'][1],
#                 marker='*', color='red', s=200, zorder=1,
#                 label="Current Location (User)" if index == 0 else "")

# y軸をLatitudeに設定
plt.xlabel('Latitude')
# x軸をLongitudeに設定
plt.ylabel('Longitude')
plt.title('Bike Positions and Home Locations')
plt.grid(True)
plt.legend()
plt.show()

print("移動後の自転車のノルムの総和:", calculate_total_distance(df_bikes))