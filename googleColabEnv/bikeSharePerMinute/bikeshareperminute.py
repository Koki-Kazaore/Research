# -*- coding: utf-8 -*-
"""bikeSharePerMinute.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KXL935KelgTmX8Cveta9kL5pfvxhVjFr

# C2Cシェアサイクルシステム

## 問題設定
個人間で自転車をシェアリングし，可能な限り乗り捨て可能とするシステムについて考える．利用可能な自転車は複数台存在し，それぞれが任意のポイントに駐輪されているとする．本システムのユーザーのサービス利用リクエストを時間幅Tの間隔で分割し，それぞれのリクエストに合わせた最適な自転車を割り当てる．

サービス利用後に任意の場所に駐輪された自転車を定位置に再配置するコストを最小化し，　より多くのユーザーに自転車を割り当てることを目的として，最適化な自転車をユーザーに割り当てる．

なお，ここではMVPとして，時間幅T=1(分)とした小規模のデータを利用することとし，最終アウトプットとしては「どのユーザーにどの自転車が割り当てられたか」と「移動後の自転車の配置状況・利用可能状況」を期待する．

[fig]

### データ
データとしては，以下のような情報を必要とする．
- 定数
 - $T$：ユーザーリクエストを区切る時間幅
- 変数
 - $J$：ユーザーリクエストデータ(データフレーム？)
 - $B$：利用可能な自転車データ(データフレーム？)

 etc
"""

# ライブラリのインストール
!pip install pulp

import pulp
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# データの準備

'''locationID検索用CSV'''
df_locations = pd.read_csv('/content/taxi_zone_lookup_with_coordinates.csv')
# df_locations.set_index("LocationID", inplace=True)
print(df_locations.head())


# LocationIDから経度と緯度をタプルで返す関数
def get_coordinates_by_location_id(location_id):
    row = df_locations[df_locations['LocationID'] == location_id]
    if not row.empty:
        return (row.iloc[0]['Latitude'], row.iloc[0]['Longitude'])
    else:
        return None

'''自転車の集合'''
# ランダムシードを設定して、ランダムに10個選択
np.random.seed(42)
random_sample = df_locations.sample(n=10)

# Bike IDを設定
random_sample['Bike ID'] = range(10)

# 緯度と経度をホームポジションとカレントポジションに設定
random_sample['Home Position'] = list(zip(random_sample['Latitude'], random_sample['Longitude']))
random_sample['Current Location'] = random_sample['Home Position']

# 結果のデータフレームを整形
B = random_sample[['Bike ID', 'Home Position', 'Current Location']]
B.set_index("Bike ID", inplace=True)

# データの中身を確認
B

'''ユーザーリクエストの集合'''
# ParquetファイルのURL
url = 'https://d37ci6vzurychx.cloudfront.net/trip-data/yellow_tripdata_2023-01.parquet'

# Parquetファイルを読み込む
df = pd.read_parquet(url)

# 指定されたカラムのみを含むデータフレームを取得
df_requests = df[['tpep_pickup_datetime', 'tpep_dropoff_datetime', 'PULocationID', 'DOLocationID']]

# データのフィルタリング
# 2023年1月1日以前のデータを削除
df_requests = df_requests[df_requests['tpep_pickup_datetime'] >= '2023-01-01']
# 2023年2月1日以降のデータを削除
df_requests = df_requests[df_requests['tpep_pickup_datetime'] <= '2023-01-31']

# ピックアップタイムの昇順で並び替え
df_requests = df_requests.sort_values(by='tpep_pickup_datetime')

# インデックスをリセット
df_requests = df_requests.reset_index(drop=True)

# フィルタリングされたデータの先頭を表示
print(df_requests.head())

# データフレームの情報を表示
print(df_requests.info())

# モデリングするためにユーザーリクエストデータを整形する

# tpep_pickup_datetimeをdatetime型に変換
df_requests['tpep_pickup_datetime'] = pd.to_datetime(df_requests['tpep_pickup_datetime'])
df_requests['tpep_dropoff_datetime'] = pd.to_datetime(df_requests['tpep_dropoff_datetime'])

# 一か月分のデータを一分ごとに分割
start_time = df_requests['tpep_pickup_datetime'].min()
end_time = df_requests['tpep_pickup_datetime'].max()

# 最初の1分のデータを抽出
start_time = df_requests['tpep_pickup_datetime'].min()
end_time = start_time + pd.Timedelta(minutes=1)

# まずは最初の1分間のリクエストをユーザーリクエストの集合として扱う
J = df_requests[(df_requests['tpep_pickup_datetime'] >= start_time) & (df_requests['tpep_pickup_datetime'] < end_time)]

# type(J)
J

import numpy as np
from pandas import DataFrame
from geopy.distance import geodesic


def generate_after_trip_distances(
    df_bikes: DataFrame,
    df_requests: DataFrame,
) -> np.ndarray:

    # 自転車とリクエストの数
    num_bikes = len(df_bikes)
    num_requests = len(df_requests)

    # 移動後の距離行列 d を作成 (d[b, j] が利用者 j が移動した後の自転車 b とその定位置までの距離)
    # 距離行列を初期化
    after_trip_distances = np.zeros((num_bikes, num_requests))
    for b in range(num_bikes):
        home_position = df_bikes.loc[b, 'Home Position']
        for j in range(num_requests):
            request_destination_id = df_requests.loc[j, 'DOLocationID']
            request_destination = get_coordinates_by_location_id(request_destination_id)
            after_trip_distances[b, j] = geodesic(
                home_position, request_destination
            ).m  # 単位はメートル

    return after_trip_distances

# デバッグ
result = generate_after_trip_distances(B, J)
print(result)

"""

---

"""

num_people = 30
num_cars = 10
car_capacity = 6

import numpy as np
from geopy.distance import geodesic


def generate_problem(
    num_people: int,
    num_cars: int,
    latitude_range: tuple[float, float],
    longitude_range: tuple[float, float],
    seed=999,
) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
    rng = np.random.default_rng(seed)

    # 利用者と車の座標を生成
    people_coords = rng.uniform(
        low=np.array([latitude_range[0], longitude_range[0]]),
        high=np.array([latitude_range[1], longitude_range[1]]),
        size=(num_people, 2),
    )
    car_coords = rng.uniform(
        low=np.array([latitude_range[0], longitude_range[0]]),
        high=np.array([latitude_range[1], longitude_range[1]]),
        size=(num_cars, 2),
    )

    # 距離行列 d を作成 (d[i, k] が利用者 i と車 k の距離)
    distances = np.zeros((num_people, num_cars))
    for i in range(num_people):
        for k in range(num_cars):
            distances[i, k] = geodesic(
                people_coords[i], car_coords[k]
            ).m  # 単位はメートル

    return people_coords, car_coords, distances

# 船橋駅周辺
latitude_range = (35.675500, 35.76)
longitude_range = (139.9, 140.08)

people_coords, car_coords, distances = generate_problem(
    num_people, num_cars, latitude_range, longitude_range
)

print(people_coords)

import folium


def plot_people_and_cars(
    people_coords: np.ndarray,
    car_coords: np.ndarray,
    latitude_range: tuple[float, float],  # 描画範囲 (緯度)
    longitude_range: tuple[float, float],  # 描画範囲 (経度)
):
    m = folium.Map(
        [sum(latitude_range) / 2, sum(longitude_range) / 2],
        tiles="OpenStreetMap",
        zoom_start=12,
    )

    for latitude, longitude in people_coords:
        folium.Marker(
            location=(latitude, longitude),
            icon=folium.Icon(icon="user", prefix="fa", color="orange"),
        ).add_to(m)

    for latitude, longitude in car_coords:
        folium.Marker(
            location=(latitude, longitude),
            icon=folium.Icon(icon="car", prefix="fa", color="green"),
        ).add_to(m)

    return m

plot_people_and_cars(people_coords, car_coords, latitude_range, longitude_range)

import numpy as np

average = distances.mean()
print(average)
std = distances.std()
print(std)
distances: np.ndarray = (distances - average) / std
print(np.array(distances))

!pip install amplify

from amplify import VariableGenerator

gen = VariableGenerator()
q = gen.array("Binary", num_people, num_cars)

from amplify import sum

alpha = 1.0

# 第一項: 利用者の移動距離を短くする
distance_objective = (distances * q).sum()

# 第二項: 乗車率の二乗和を大きくする
occupancies = q.sum(axis=0) / car_capacity  # 乗車率
occupancy_objective = (occupancies**2).sum()

objective = distance_objective - alpha * occupancy_objective

from amplify import one_hot

one_person_one_car_constraints = one_hot(q, axis=1)

from amplify import less_equal

car_capacity_constraints = less_equal(q, car_capacity, axis=0)

one_person_one_car_constraints *= np.max(distances) + alpha * 1
car_capacity_constraints *= np.max(distances) + alpha * 2 / car_capacity

from amplify import Model

model = objective + one_person_one_car_constraints + car_capacity_constraints

from amplify import FixstarsClient, solve
from datetime import timedelta

client = FixstarsClient()
client.parameters.timeout = timedelta(milliseconds=2000)  # タイムアウトは 2000 ms
# client.token = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"  # ローカル環境等で使用する場合は、Fixstars Amplify AE のアクセストークンを入力してください。

result = solve(model, client)
if len(result) == 0:
    # 実行可能解が見つかっていなければ例外を投げる
    raise RuntimeError("No feasible solution was found.")