# -*- coding: utf-8 -*-
"""bikeSharePerMinute.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KXL935KelgTmX8Cveta9kL5pfvxhVjFr

# C2Cシェアサイクルシステム

## 問題設定
個人間で自転車をシェアリングし，可能な限り乗り捨て可能とするシステムについて考える．利用可能な自転車は複数台存在し，それぞれが任意のポイントに駐輪されているとする．本システムのユーザーのサービス利用リクエストを時間幅Tの間隔で分割し，それぞれのリクエストに合わせた最適な自転車を割り当てる．

サービス利用後に任意の場所に駐輪された自転車を定位置に再配置するコストを最小化し，　より多くのユーザーに自転車を割り当てることを目的として，最適化な自転車をユーザーに割り当てる．

なお，ここではMVPとして，時間幅T=1(分)とした小規模のデータを利用することとし，最終アウトプットとしては「どのユーザーにどの自転車が割り当てられたか」と「移動後の自転車の配置状況・利用可能状況」を期待する．

[fig]

### データ
データとしては，以下のような情報を必要とする．
- 定数
 - $T$：ユーザーリクエストを区切る時間幅
- 変数
 - $J$：ユーザーリクエストデータ(データフレーム？)
 - $B$：利用可能な自転車データ(データフレーム？)

 etc
"""

# ライブラリのインストール
!pip install ortools

import branca.colormap as cm
import folium
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from geopy.distance import geodesic
from ortools.linear_solver import pywraplp
from pandas import DataFrame

# データの準備

'''locationID検索用CSV'''
df_locations = pd.read_csv('/content/taxi_zone_lookup_with_coordinates.csv')
# df_locations.set_index("LocationID", inplace=True)
print(df_locations.head())


# LocationIDから経度と緯度をタプルで返す関数
def get_coordinates_by_location_id(location_id):
    row = df_locations[df_locations['LocationID'] == location_id]
    if not row.empty:
        return (row.iloc[0]['Latitude'], row.iloc[0]['Longitude'])
    else:
        return None

'''自転車の集合'''
# ランダムシードを設定して、ランダムに10個選択
np.random.seed(42)
random_sample = df_locations.sample(n=10)

# Bike IDを設定
random_sample['Bike ID'] = range(10)

# 緯度と経度をホームポジションとカレントポジションに設定
random_sample['Home Position'] = list(zip(random_sample['Latitude'], random_sample['Longitude']))
random_sample['Current Location'] = random_sample['Home Position']

# 結果のデータフレームを整形
B = random_sample[['Bike ID', 'Home Position', 'Current Location']]
B.set_index("Bike ID", inplace=True)

# データの中身を確認
B

'''ユーザーリクエストの集合'''
# ParquetファイルのURL
url = 'https://d37ci6vzurychx.cloudfront.net/trip-data/yellow_tripdata_2023-01.parquet'

# Parquetファイルを読み込む
df = pd.read_parquet(url)

# 指定されたカラムのみを含むデータフレームを取得
df_requests = df[['tpep_pickup_datetime', 'tpep_dropoff_datetime', 'PULocationID', 'DOLocationID']]

# データのフィルタリング
# 2023年1月1日以前のデータを削除
df_requests = df_requests[df_requests['tpep_pickup_datetime'] >= '2023-01-01']
# 2023年2月1日以降のデータを削除
df_requests = df_requests[df_requests['tpep_pickup_datetime'] <= '2023-01-31']

# ピックアップタイムの昇順で並び替え
df_requests = df_requests.sort_values(by='tpep_pickup_datetime')

# インデックスをリセット
df_requests = df_requests.reset_index(drop=True)

# フィルタリングされたデータの先頭を表示
print(df_requests.head())

# データフレームの情報を表示
print(df_requests.info())

# モデリングするためにユーザーリクエストデータを整形する

# tpep_pickup_datetimeをdatetime型に変換
df_requests['tpep_pickup_datetime'] = pd.to_datetime(df_requests['tpep_pickup_datetime'])
df_requests['tpep_dropoff_datetime'] = pd.to_datetime(df_requests['tpep_dropoff_datetime'])

# 一か月分のデータを一分ごとに分割
# start_time = df_requests['tpep_pickup_datetime'].min()
# end_time = df_requests['tpep_pickup_datetime'].max()

# 最初の1分のデータを抽出
start_time = df_requests['tpep_pickup_datetime'].min()
end_time = start_time + pd.Timedelta(minutes=1)

# まずは最初の1分間のリクエストをユーザーリクエストの集合として扱う
J = df_requests[(df_requests['tpep_pickup_datetime'] >= start_time) & (df_requests['tpep_pickup_datetime'] < end_time)]

# type(J)
J

'''ユーザーリクエストJに対して移動後の自転車Bの位置関係を表す距離行列を返す関数'''
def generate_after_trip_distances(
    df_bikes: DataFrame,
    df_requests: DataFrame,
) -> np.ndarray:

    # 自転車とリクエストの数
    num_bikes = len(df_bikes)
    num_requests = len(df_requests)

    # 移動後の距離行列 d を作成 (d[b, j] が利用者 j が移動した後の自転車 b とその定位置までの距離)
    # 距離行列を初期化
    after_trip_distances = np.zeros((num_bikes, num_requests))
    for b in range(num_bikes):
        home_position = df_bikes.loc[b, 'Home Position']
        for j in range(num_requests):
            request_destination_id = df_requests.loc[j, 'DOLocationID']
            request_destination = get_coordinates_by_location_id(request_destination_id)
            after_trip_distances[b, j] = geodesic(
                home_position, request_destination
            ).m  # 単位はメートル

    return after_trip_distances


'''ユーザーリクエストJに対して移動前の自転車Bの位置関係を表す距離行列を返す関数'''
def generate_before_trip_distances(
    df_bikes: pd.DataFrame,
    df_requests: pd.DataFrame,
) -> np.ndarray:

    # 自転車とリクエストの数
    num_bikes = len(df_bikes)
    num_requests = len(df_requests)

    # 移動前の距離行列 d を作成 (d[b, j] が利用者 j のリクエスト地点と自転車 b の現在地との距離)
    # 距離行列を初期化
    before_trip_distances = np.zeros((num_bikes, num_requests))
    for b in range(num_bikes):
        current_location = df_bikes.loc[b, 'Current Location']
        for j in range(num_requests):
            request_pickup_id = df_requests.loc[j, 'PULocationID']
            request_pickup = get_coordinates_by_location_id(request_pickup_id)
            before_trip_distances[b, j] = geodesic(
                current_location, request_pickup
            ).m  # 単位はメートル

    return before_trip_distances

# デバッグ
# ユーザーリクエストJに対して移動された自転車Bにおける、自転車の定位置との距離行列
distances = generate_after_trip_distances(B, J)
print(distances)

'''ユーザーの位置と自転車の位置をプロットする関数'''
def plot_users_and_bikes(
    user_locations: np.ndarray,
    bike_locations: np.ndarray,
    latitude_range: tuple[float, float],  # 描画範囲 (緯度)
    longitude_range: tuple[float, float],  # 描画範囲 (経度)
):
    m = folium.Map(
        [sum(latitude_range) / 2, sum(longitude_range) / 2],
        tiles="OpenStreetMap",
        zoom_start=11,
    )

    for latitude, longitude in user_locations:
        folium.Marker(
            location=(latitude, longitude),
            icon=folium.Icon(icon="user", prefix="fa", color="orange"),
        ).add_to(m)

    for latitude, longitude in bike_locations:
        folium.Marker(
            location=(latitude, longitude),
            icon=folium.Icon(icon="bicycle", prefix="fa", color="green"),
        ).add_to(m)

    return m

# latitudeカラムとlongitudeカラムの最大値と最小値を取得
latitude_max = df_locations['Latitude'].max()
latitude_min = df_locations['Latitude'].min()
longitude_max = df_locations['Longitude'].max()
longitude_min = df_locations['Longitude'].min()

# 結果を表示
print(f"Latitude: max = {latitude_max}, min = {latitude_min}")
print(f"Longitude: max = {longitude_max}, min = {longitude_min}")

# NYC
latitude_range = (latitude_min - 0.1, latitude_max + 0.1)
longitude_range = (longitude_min - 0.1, longitude_max + 0.1)
print(latitude_range)
print(longitude_range)

# 自転車の現在地の配列
current_locations = B['Current Location'].values
print(type(current_locations))
print(current_locations)

# ユーザーの現在地の配列
request_origin_ids = J['PULocationID']
request_origins = []
for origin_id in request_origin_ids:
    request_origins.append(get_coordinates_by_location_id(origin_id))
request_origins = np.array(request_origins)
print(type(request_origins))
print(request_origins)

plot_users_and_bikes(request_origins, current_locations, latitude_range, longitude_range)

# 問題の正規化
average = distances.mean()
print(f"average: {average}")
std = distances.std()
print(f"std: {std}")
distances: np.ndarray = (distances - average) / std
print(f"distances: {distances}")

# OR-Toolsのソルバーを作成
solver = pywraplp.Solver.CreateSolver('SCIP')

# 変数の定義
x = []
for b in range(B.shape[0]):
    x.append([])
    for j in range(J.shape[0]):
        x[b].append(solver.BoolVar(f'x[{b},{j}]'))
print(x)

alpha = 1.0

# 目的関数の定義
# 第一項: ユーザーの移動後の自転車の現在地と定位置との距離を短くする
distance_objective = solver.Sum(distances[b][j] * x[b][j] for b in range(B.shape[0]) for j in range(J.shape[0]))
# 第二項: より多くのユーザーに自転車を割り当てる
sum_x = solver.Sum(x[b][j] for b in range(B.shape[0]) for j in range(J.shape[0]))

objective = distance_objective - alpha * sum_x
solver.Minimize(objective)

# 制約条件の定義

# 各ユーザーは1台の自転車にしか割り当てられない
for b in range(B.shape[0]):
    solver.Add(solver.Sum(x[b][j] for j in range(J.shape[0])) <= 1)

# 各自転車は１人のユーザーにしか割り当てられない
for j in range(J.shape[0]):
    solver.Add(solver.Sum(x[b][j] for b in range(B.shape[0])) <= 1)

# ソルバーを実行
status = solver.Solve()
print(status)

if status == pywraplp.Solver.OPTIMAL:
    print('解が見つかりました:')
    bike_assignment = []
    for b in range(B.shape[0]):
        for j in range(J.shape[0]):
            if x[b][j].solution_value() == 1:
                bike_assignment.append((b, j))
                print(f"利用者 {j}: 自転車 {b}")
else:
    raise RuntimeError("No feasible solution was found.")

print(bike_assignment)

# debug
# for i in range(10):
#   for j in range(12):
#     print(x[i][j].solution_value())

'''自転車とユーザーを，割り当てられた自転車ごとに異なる色で塗り分けてプロットする関数'''
def plot_result(
    bike_assignment: list[tuple[int, int]],
    user_locations: np.ndarray,
    bike_locations: np.ndarray,
    latitude_range: tuple[float, float],  # 描画範囲 (緯度)
    longitude_range: tuple[float, float],  # 描画範囲 (経度)
):
    # マップを用意
    m = folium.Map(
        [sum(latitude_range) / 2, sum(longitude_range) / 2],
        tiles="OpenStreetMap",
        zoom_start=11,
    )

    # 色の用意
    colormap = cm.linear.Set1_09.scale(0, len(bike_locations)).to_step(len(bike_locations))  # type: ignore

    # 車のプロット (k 番目の自転車を色 k で塗る)
    for bike_index, (latitude, longitude) in enumerate(bike_locations):
        folium.Marker(
            location=(latitude, longitude),
            popup=f"bike {bike_index}",
            icon=folium.Icon(
                icon="bicycle", prefix="fa", color="white", icon_color=colormap(bike_index)
            ),
        ).add_to(m)

    # 利用者のプロット (自転車 k に乗るユーザーを色 k で塗る)
    for bike_index, user_index in bike_assignment:
        latitude, longitude = user_locations[user_index]
        folium.Marker(
            location=(latitude, longitude),
            popup=f"bike {bike_index}",
            icon=folium.Icon(
                icon="user",
                prefix="fa",
                color="white",
                icon_color=colormap(bike_index),
            ),
        ).add_to(m)

    return m

plot_result(bike_assignment, request_origins, current_locations, latitude_range, longitude_range)

"""

---

"""