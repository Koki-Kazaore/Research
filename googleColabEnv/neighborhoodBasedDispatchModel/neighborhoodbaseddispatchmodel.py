# -*- coding: utf-8 -*-
"""neighborhoodBasedDispatchModel.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1B4g1IxAAx6QImiPY-16ekeQAeBYDfLXn

# neighborhoodBasedDispatchModel
- @param `df_locations` : pd.Dataframe型の地理情報データ
- @param `df_bikes` : pd.Dataframe型の自転車データ
- @return `neighborhoodBasedDispatchModel`

## solve()
- @param `df_request` : pd.Dataframe型のユーザーリクエスト
- @return `result` : 自転車IDと割り当てられたユーザーのキューインデックス
"""

import branca.colormap as cm
import folium
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from datetime import datetime
from geopy.distance import geodesic
from pandas import DataFrame
from scipy.interpolate import PchipInterpolator

# データの準備

'''locationID検索用CSV'''
df_locations = pd.read_csv('/content/taxi_zone_lookup_with_coordinates.csv')

# 最後の2行を除外
df_locations = df_locations.iloc[:-2]

print(df_locations.head())
print(df_locations.tail())

print([repr(col) for col in df_locations.columns])

df_locations.columns = df_locations.columns.str.strip()
print([repr(col) for col in df_locations.columns])

'''自転車の集合'''
# ランダムシードを設定して、ランダムにn個選択
np.random.seed(42)
random_sample = df_locations.sample(n=650, replace=True)

# Bike IDを設定
random_sample['Bike ID'] = range(650)

# 緯度と経度をホームポジションとカレントポジションに設定
random_sample['Home Position'] = list(zip(random_sample['Latitude'], random_sample['Longitude']))
random_sample['Current Location'] = random_sample['Home Position']

# 結果のデータフレームを整形
B = random_sample[['Bike ID', 'Home Position', 'Current Location']]
B.set_index("Bike ID", inplace=True)

# DODatetimeカラムを追加して初期値をNaTに設定
B['DODatetime'] = pd.NaT

# データの中身を確認
B

'''ユーザーリクエストの集合'''

STARTING_DATE = '2023-01-01 0:00'
END_DATE = '2023-01-02 0:00'

# ParquetファイルのURL
url = 'https://d37ci6vzurychx.cloudfront.net/trip-data/yellow_tripdata_2023-01.parquet'

# Parquetファイルを読み込む
df = pd.read_parquet(url)

# 指定されたカラムのみを含むデータフレームを取得
df_requests = df[['tpep_pickup_datetime', 'tpep_dropoff_datetime', 'PULocationID', 'DOLocationID']]

# データのフィルタリング
# 2023年1月1日以前のデータを削除
df_requests = df_requests[df_requests['tpep_pickup_datetime'] >= STARTING_DATE]
# 2023年2月1日以降のデータを削除
df_requests = df_requests[df_requests['tpep_pickup_datetime'] < END_DATE]

# ピックアップタイムの昇順で並び替え
df_requests = df_requests.sort_values(by='tpep_pickup_datetime')

# インデックスをリセット
df_requests = df_requests.reset_index(drop=True)

# フィルタリングされたデータの先頭を表示
print(df_requests.head())

# データフレームの情報を表示
print(df_requests.info())

# neighborhoodBasedDispatchModelクラスを定義
class neighborhoodBasedDispatchModel:
    def __init__(self, df_locations, df_bikes):
        self.df_locations = df_locations
        self.df_bikes = df_bikes


    '''LocationIDから経度と緯度をタプルで返す関数'''
    def _get_coordinates_by_location_id(self, location_id):
        row = self.df_locations[self.df_locations['LocationID'] == location_id]
        if not row.empty:
            latitude = row.iloc[0]['Latitude']
            longitude = row.iloc[0]['Longitude']
            # 緯度と経度が有効な数値であるかどうかを確認する
            if pd.notna(latitude) and pd.notna(longitude):
                return (latitude, longitude)
            else:
                return None
        else:
            return None


    '''利用可能な自転車を取得する'''
    def _get_available_bikes(
        self,
        current_time: datetime = None
    ) -> np.ndarray:
        # current_timeがNoneの場合、現在時刻を取得
        # 本番運用時はcurrent_timeを利用しない
        if current_time is None:
            current_time = datetime.now()
        else:
            current_time = pd.to_datetime(current_time)

        # 利用可能な自転車を1、不可能な自転車を0とする行列を作成
        available_bikes = (self.df_bikes['DODatetime'].isna() | (self.df_bikes['DODatetime'] < current_time)).astype(int)
        return available_bikes.values


    '''割り当て成功後の自転車ステータスの更新'''
    def _update_bike_status(
        self,
        bike_assignment,
        df_requests
    ):
        for b, j in bike_assignment:
            # jのtpep_dropoff_datetimeを取得するし自転車ステータス更新する
            # df_requestsのインデックスjに対応する行を取得
            print('-----df_requests.loc[j]-----')
            print(df_requests.loc[j])
            request_row = df_requests.loc[j]
            self.df_bikes.at[b, 'DODatetime'] = request_row['tpep_dropoff_datetime']
            # jのDOLocationIDを取得して自転車のCurrent Locationを更新する
            self.df_bikes.at[b, 'Current Location'] = self._get_coordinates_by_location_id(request_row['DOLocationID'])


    '''結果出力用メソッド'''
    def _print_results(self, result_dict):
        # 辞書型のそれぞれのデータに対して"key: value"形式で出力する
        for key, value in result_dict.items():
            print(f"{key}: {value}")
        # print("-------------------------------------------------------")


    '''ランダム割り当てメイン処理'''
    '''retun bike_assignment = [(b, j)]'''
    def solve(self, df_request):
        # 利用可能な自転車を取得する
        current_time = df_request.iloc[-1]['tpep_pickup_datetime']
        available_bikes = self._get_available_bikes(current_time)
        print(available_bikes)

        if not available_bikes.any():
            print("No available bikes.")
            return []

        # 利用可能な自転車のインデックスを取得
        available_bike_indices = np.where(available_bikes == 1)[0]

        # リクエスト数(1つ)と利用可能な自転車数を比較して、少ない方を割り当て数とする
        # num_assignments = 1
        num_assignments = min(len(df_request), len(available_bike_indices))

        # リクエストのPULocationIDから座標を取得し、最も近い自転車を割り当てる
        bike_assignment = []
        for i in range(num_assignments):
            pickup_location_id = df_request.iloc[i]['PULocationID']
            print('test: ', pickup_location_id)
            pickup_coordinates = self._get_coordinates_by_location_id(pickup_location_id)

            # 最も近い自転車を検索
            min_distance = float('inf')
            closest_bike_index = None
            for b in available_bike_indices:
                bike_id = self.df_bikes.index[b]
                bike_coordinates = self.df_bikes.loc[bike_id, 'Current Location']
                distance = geodesic(pickup_coordinates, bike_coordinates).meters
                if distance < min_distance:
                    min_distance = distance
                    closest_bike_index = b

            # 最も近い自転車を割り当て
            bike_assignment.append((closest_bike_index, df_request.index[i]))

        # _print_results()に結果を渡して出力する
        result_dict = {
            "bike_assignment": bike_assignment,
        }
        self._print_results(result_dict) #←モデル検証・デバッグ用
        # 自転車ステータスを更新
        self._update_bike_status(bike_assignment, df_request)
        return bike_assignment

"""# 動作確認"""

# neighborhoodBasedDispatchModelの初期化・インスタンス作成
neighborhoodBasedDispatchModel = neighborhoodBasedDispatchModel(df_locations, B)

def calculate_total_distance(df):
    """
    データフレームからホームポジションとカレントポジションのノルムの総和を計算する関数。

    :param df: ホームポジションとカレントポジションを含むデータフレーム
    :return: 距離の総和
    """
    total_distance = 0
    for _, row in df.iterrows():
        home_pos = np.array(row['Home Position'])
        current_loc = np.array(row['Current Location'])
        distance = np.linalg.norm(home_pos - current_loc)
        total_distance += distance
    return total_distance

# モデリングするためにユーザーリクエストデータを整形する

# tpep_pickup_datetimeをdatetime型に変換
df_requests['tpep_pickup_datetime'] = pd.to_datetime(df_requests['tpep_pickup_datetime'])
df_requests['tpep_dropoff_datetime'] = pd.to_datetime(df_requests['tpep_dropoff_datetime'])

# リクエストデータを一分ごとに分割
start_time = df_requests['tpep_pickup_datetime'].min()
end_time = df_requests['tpep_pickup_datetime'].max()
print(f"リクエストの開始時間：{start_time}")
print(f"リクエストの終了時間：{end_time}")
print(f"リバランスコスト初期値：{calculate_total_distance(B)}")

# マッチングプロセスのログデータ収集用時系列データ
time_series_log_data = []

# df_requestsを一行ずつ処理
for index, request_row in df_requests.iterrows():
    current_time = request_row['tpep_pickup_datetime']
    print(f"Time: {current_time}")

    # 現在のリクエストを抽出
    J = df_requests.iloc[[index]]  # 現在の行をDataFrameとして抽出
    # print(J)

    # PULocationIDまたはDOLocationIDが262より大きい場合は不正なリクエストとしてエラー文を出力して次の処理へスキップする
    if J['PULocationID'].values[0] > 262 or J['DOLocationID'].values[0] > 262:
        print("Invalid request. PULocationID or DOLocationID is greater than 262.")
        print("-------------------------------------------------------")
        continue

    # solve()を実行
    try:
        bike_assignment = neighborhoodBasedDispatchModel.solve(J)
    except RuntimeError:
        bike_assignment = []
        print("No feasible solution was found.")
        print("-------------------------------------------------------")

    # 自転車占有率を計算する
    available_bikes = neighborhoodBasedDispatchModel._get_available_bikes(current_time)
    bikes_occupied_rate = 1 - available_bikes.sum() / len(available_bikes)
    print(f"Bikes Occupied Rate: {bikes_occupied_rate}")

    # マッチング成功率を計算する
    matching_success_rate = len(bike_assignment) / len(J)
    print(f"Matching Success Rate: {matching_success_rate}")

    # 自転車の再配置コストを計算する
    rebalance_cost = calculate_total_distance(B)
    print(f"Rebalance Cost: {rebalance_cost}")
    print("-------------------------------------------------------")

    # ログ出力
    time_series_log_data.append({
        'time': current_time,
        'matching_success_rate': matching_success_rate,
        'bikes_occupied_rate': bikes_occupied_rate,
        'rebalance_cost': rebalance_cost
    })

# 自転車のステータスを確認
B

# 自転車の割り当て成功率と占有率とリバランスコストの関係をグラフ化する

# ログデータをデータフレームにコンバートする
df_time_series = pd.DataFrame(time_series_log_data)

# 時間データを数値に変換
df_time_series['time'] = pd.to_numeric(df_time_series['time']) # Convert datetime to numeric
df_time_series.sort_values('time', inplace=True) # Sort by time
df_time_series.drop_duplicates(subset='time', inplace=True) # Remove duplicates
time = df_time_series['time'].values / 1e9  # 秒に変換

# 補間のための新しい時間データを作成
time_new = np.linspace(time.min(), time.max(), 300)

# PCHIP補間
pchip_matching_success_rate = PchipInterpolator(time, df_time_series['matching_success_rate'])
matching_success_rate_smooth = pchip_matching_success_rate(time_new)

pchip_bikes_occupied_rate = PchipInterpolator(time, df_time_series['bikes_occupied_rate'])
bikes_occupied_rate_smooth = pchip_bikes_occupied_rate(time_new)

pchip_rebalance_cost = PchipInterpolator(time, df_time_series['rebalance_cost'])
rebalance_cost_smooth = pchip_rebalance_cost(time_new)

# プロット
fig, ax1 = plt.subplots(figsize=(10, 6))

# 新しい時間データをDateTimeに変換してプロット
time_new_datetime = pd.to_datetime(time_new * 1e9)

# 左側のY軸に割り当て成功率と自転車の占有率をプロット
ax1.plot(time_new_datetime, matching_success_rate_smooth, label='Matching Success Rate', color='b')
ax1.plot(time_new_datetime, bikes_occupied_rate_smooth, label='Bikes Occupied Rate', color='g')
ax1.set_xlabel('Time')
ax1.set_ylabel('Rate', color='k')
ax1.tick_params(axis='y', labelcolor='k')

# 右側のY軸にリバランスコストをプロット
ax2 = ax1.twinx()
ax2.plot(time_new_datetime, rebalance_cost_smooth, label='Rebalance Cost', color='r')
ax2.set_ylabel('Rebalance Cost', color='k')
ax2.tick_params(axis='y', labelcolor='k')

# グラフのタイトルと凡例の設定
fig.suptitle('Matching Success Rate, Bikes Occupied Rate, and Rebalance Cost Over Time')
fig.legend(loc='upper left', bbox_to_anchor=(0.1,0.9))

ax1.grid(True)

plt.show()

"""# 最終自転車分布"""

'''ユーザーの位置と自転車の位置をプロットする関数'''
def plot_users_and_bikes(
    user_locations: np.ndarray,
    bike_locations: np.ndarray,
    latitude_range: tuple[float, float],  # 描画範囲 (緯度)
    longitude_range: tuple[float, float],  # 描画範囲 (経度)
):
    m = folium.Map(
        [sum(latitude_range) / 2, sum(longitude_range) / 2],
        tiles="OpenStreetMap",
        zoom_start=11,
    )

    for latitude, longitude in user_locations:
        folium.Marker(
            location=(latitude, longitude),
            icon=folium.Icon(icon="user", prefix="fa", color="orange"),
        ).add_to(m)

    for latitude, longitude in bike_locations:
        folium.Marker(
            location=(latitude, longitude),
            icon=folium.Icon(icon="bicycle", prefix="fa", color="green"),
        ).add_to(m)

    return m

# latitudeカラムとlongitudeカラムの最大値と最小値を取得
latitude_max = df_locations['Latitude'].max()
latitude_min = df_locations['Latitude'].min()
longitude_max = df_locations['Longitude'].max()
longitude_min = df_locations['Longitude'].min()

# 結果を表示
print(f"Latitude: max = {latitude_max}, min = {latitude_min}")
print(f"Longitude: max = {longitude_max}, min = {longitude_min}")

# NYC
latitude_range = (latitude_min - 0.1, latitude_max + 0.1)
longitude_range = (longitude_min - 0.1, longitude_max + 0.1)
print(latitude_range)
print(longitude_range)

current_locations = B['Current Location'].values
print(type(current_locations))
print(current_locations)

plot_users_and_bikes([], current_locations, latitude_range, longitude_range)

# ログのCSV出力
from google.colab import files
filename =  "result_by_neighborhoodBasedDispatchModel_650.csv"
df_time_series.to_csv(filename, encoding = 'utf-8-sig')
files.download(filename)